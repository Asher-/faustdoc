<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../../img/favicon.ico">
        <title>Using the signal API - Faust Documentation</title>
        <link href="../../css/bootstrap.min.css" rel="stylesheet">
        <link href="../../css/font-awesome.min.css" rel="stylesheet">
        <link href="../../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">
        <link href="/css/quickref.css" rel="stylesheet">
        <link href="/rail/railroad-diagrams.css" rel="stylesheet">

        <script src="../../js/jquery-1.10.2.min.js" defer></script>
        <script src="../../js/bootstrap.min.js" defer></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
        <script>hljs.initHighlightingOnLoad();</script> 
    </head>

    <body>
        <div class="navbar fixed-top navbar-expand-lg navbar-dark bg-primary">
            <div class="container">
                <a class="navbar-brand" href="../.."><img src="../../img/faustText.svg" width="150px"> </a>
                <!-- Expander button -->
                <button type="button" class="navbar-toggler" data-toggle="collapse" data-target="#navbar-collapse">
                    <span class="navbar-toggler-icon"></span>
                </button>

                <!-- Expanded navigation -->
                <div id="navbar-collapse" class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li class="navitem">
                                <a href="../.." class="nav-link">Home</a>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">Faust Manual <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../../manual/introduction/" class="dropdown-item">Introduction</a>
</li>
                                    
<li>
    <a href="../../manual/overview/" class="dropdown-item">Overview of the Faust Universe</a>
</li>
                                    
<li>
    <a href="../../manual/quick-start/" class="dropdown-item">Quick start</a>
</li>
                                    
<li>
    <a href="../../manual/syntax/" class="dropdown-item">Faust Syntax</a>
</li>
                                    
<li>
    <a href="../../manual/compiler/" class="dropdown-item">Using the Compiler</a>
</li>
                                    
<li>
    <a href="../../manual/options/" class="dropdown-item">Compiler Options</a>
</li>
                                    
<li>
    <a href="../../manual/tools/" class="dropdown-item">faust2[...] Tools</a>
</li>
                                    
<li>
    <a href="../../manual/architectures/" class="dropdown-item">Architecture Files</a>
</li>
                                    
<li>
    <a href="../../manual/embedding/" class="dropdown-item">Embedding the Compiler</a>
</li>
                                    
<li>
    <a href="../../manual/optimizing/" class="dropdown-item">Optimizing the Code</a>
</li>
                                    
<li>
    <a href="../../manual/deploying/" class="dropdown-item">Deploying on the Web</a>
</li>
                                    
<li>
    <a href="../../manual/remote/" class="dropdown-item">Remote compilation</a>
</li>
                                    
<li>
    <a href="../../manual/mathdoc/" class="dropdown-item">Mathematical Documentation</a>
</li>
                                    
<li>
    <a href="../../manual/osc/" class="dropdown-item">OSC Support</a>
</li>
                                    
<li>
    <a href="../../manual/http/" class="dropdown-item">HTTP Support</a>
</li>
                                    
<li>
    <a href="../../manual/midi/" class="dropdown-item">MIDI Support</a>
</li>
                                    
<li>
    <a href="../../manual/soundfiles/" class="dropdown-item">Soundfiles Support</a>
</li>
                                    
<li>
    <a href="../../manual/community/" class="dropdown-item">Community</a>
</li>
                                    
<li>
    <a href="../../manual/faq/" class="dropdown-item">Frequently Asked Questions</a>
</li>
                                </ul>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">Examples <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../../examples/ambisonics/" class="dropdown-item"> ambisonics </a>
</li>
                                    
<li>
    <a href="../../examples/analysis/" class="dropdown-item"> analysis </a>
</li>
                                    
<li>
    <a href="../../examples/bela/" class="dropdown-item"> bela </a>
</li>
                                    
<li>
    <a href="../../examples/delayEcho/" class="dropdown-item"> delayEcho </a>
</li>
                                    
<li>
    <a href="../../examples/dynamic/" class="dropdown-item"> dynamic </a>
</li>
                                    
<li>
    <a href="../../examples/filtering/" class="dropdown-item"> filtering </a>
</li>
                                    
<li>
    <a href="../../examples/gameaudio/" class="dropdown-item"> gameaudio </a>
</li>
                                    
<li>
    <a href="../../examples/generator/" class="dropdown-item"> generator </a>
</li>
                                    
<li>
    <a href="../../examples/misc/" class="dropdown-item"> misc </a>
</li>
                                    
<li>
    <a href="../../examples/phasing/" class="dropdown-item"> phasing </a>
</li>
                                    
<li>
    <a href="../../examples/physicalModeling/" class="dropdown-item"> physicalModeling </a>
</li>
                                    
<li>
    <a href="../../examples/pitchShifting/" class="dropdown-item"> pitchShifting </a>
</li>
                                    
<li>
    <a href="../../examples/psychoacoustic/" class="dropdown-item"> psychoacoustic </a>
</li>
                                    
<li>
    <a href="../../examples/reverb/" class="dropdown-item"> reverb </a>
</li>
                                    
<li>
    <a href="../../examples/SAM/" class="dropdown-item"> SAM </a>
</li>
                                    
<li>
    <a href="../../examples/smartKeyboard/" class="dropdown-item"> smartKeyboard </a>
</li>
                                    
<li>
    <a href="../../examples/spat/" class="dropdown-item"> spat </a>
</li>
                                    
<li>
    <a href="../../rsrc/examples.zip" class="dropdown-item"> Download examples </a>
</li>
                                </ul>
                            </li>
                            <li class="dropdown active">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">Tutorials <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../../workshops/2020-04-10-faust-juce/" class="dropdown-item">Faust & JUCE</a>
</li>
                                    
<li>
    <a href="../teensy/" class="dropdown-item">DSP on the Teensy With Faust</a>
</li>
                                    
<li>
    <a href="../esp32/" class="dropdown-item">DSP on the ESP-32 With Faust</a>
</li>
                                    
<li>
    <a href="../basic-osc/" class="dropdown-item">Making a Sine Oscillator From Scratch</a>
</li>
                                    
<li>
    <a href="../summation/" class="dropdown-item">RMS and Summation in Faust</a>
</li>
                                    
<li>
    <a href="../julia/" class="dropdown-item">Using Faust in Julia</a>
</li>
                                    
<li>
    <a href="./" class="dropdown-item active">Using the signal API</a>
</li>
                                </ul>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">Workshops <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../../workshops/2018-12-01-paw/" class="dropdown-item"> 2018-12-01 PAW </a>
</li>
                                    
<li>
    <a href="../../workshops/2020-03-24-faust-citi/" class="dropdown-item"> 2020-03-24 CITI </a>
</li>
                                    
<li>
    <a href="../../workshops/2020-04-10-faust-101/" class="dropdown-item"> 2020-04-10 Faust 101 </a>
</li>
                                    
<li>
    <a href="../../workshops/2020-04-10-faust-juce/" class="dropdown-item"> 2020-04-10 Faust & JUCE </a>
</li>
                                    
<li>
    <a href="../../workshops/2020-11-21-faust-vcvrack/" class="dropdown-item"> 2020-11-21 Faust & VCV Rack </a>
</li>
                                </ul>
                            </li>
                            <li class="navitem">
                                <a href="../../about/" class="nav-link">About</a>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav ml-auto">
                        <li class="nav-item">
                            <a href="#" class="nav-link" data-toggle="modal" data-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                    </ul>
                </div>
            </div>
        </div>
        
        

        <div class="container">
            <div class="row"><div class="col-md-3"><div class="navbar-light navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-toggle="collapse" data-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-secondary">
        <ul class="nav flex-column">
            
            <li class="nav-item" data-level="1"><a href="#using-the-signal-api" class="nav-link">Using the signal API</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="4"><a href="#accessing-the-signal-stage" class="nav-link">Accessing the signal stage</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#who-is-this-tutorial-for" class="nav-link">Who is this tutorial for?</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#compiling-signal-expressions" class="nav-link">Compiling signal expressions</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="3"><a href="#examples" class="nav-link">Examples</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="4"><a href="#tools" class="nav-link">Tools</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#simple-constant-signal" class="nav-link">Simple constant signal</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#doing-some-mathematical-operations-on-an-input-signal" class="nav-link">Doing some mathematical operations on an input signal</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#defining-delayed-signals" class="nav-link">Defining delayed signals</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#equivalent-signal-expressions" class="nav-link">Equivalent signal expressions</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#using-user-interface-items" class="nav-link">Using User Interface items</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#defining-recursive-signals" class="nav-link">Defining recursive signals</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#accessing-the-global-context" class="nav-link">Accessing the global context</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#using-tables-todo" class="nav-link">Using tables (TODO)</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#using-waveforms-todo" class="nav-link">Using waveforms (TODO)</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#using-soundfiles-todo" class="nav-link">Using soundfiles (TODO)</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#defining-more-complex-expressions-a-phasor-then-an-oscillator" class="nav-link">Defining more complex expressions: a phasor then an oscillator</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#executing-the-generated-code" class="nav-link">Executing the generated code</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="4"><a href="#connecting-the-audio-layer-todo" class="nav-link">Connecting the audio layer (TODO)</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#connecting-the-controller-layer-todo" class="nav-link">Connecting the controller layer (TODO)</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#creating-a-signal-language-based-on-this-api" class="nav-link">Creating a signal language based on this API</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
        </ul>
    </div>
</div></div>
                    <div class="col-md-9 main-container" role="main">

<h1 id="using-the-signal-api">Using the signal API</h1>
<p>The Faust compiler is composed of several steps and has the following scheme:</p>
<p><img src="img/compilation-chain.png" class="mx-auto d-block" width="60%">
<center><em>The compilation chain</em></center></p>
<p>Starting from the DSP source code, the <em>Semantic Phase</em> produces signals as conceptually infinite streams of samples or control values. Those signals are then compiled in imperative code (C/C++, LLVM IR, WebAssembly, etc.) in the <em>Code Generation Phase</em>.</p>
<p>The <em>Semantic Phase</em> is decomposed as explained in the following scheme:</p>
<p><img src="img/semantic-phase.png" class="mx-auto d-block" width="80%">
<center><em>The semantic phase</em></center></p>
<p>The list of output signals is produced by the <em>Symbolic Propagation</em> step. Each output signal is then simplified and a set of optimizations are done (normal form computation and simplification, delay line sharing, typing, etc.) to finally produce a <em>list of output signals in normal form</em>. </p>
<p>The <em>Code Generation Phase</em> translates the signals in an intermediate representation named FIR (Faust Imperative Representation) which is then converted to the final target language (C/C++, LLVM IR, WebAssembly,etc.) with a set of backends.</p>
<h4 id="accessing-the-signal-stage">Accessing the signal stage</h4>
<p>A new intermediate entry point has been created in the <em>Semantic Phase</em> to allow the creation of output signals, then beneficiate of all remaining parts of the compilation chain. The <em>signal API</em> allows to programmatically create a signal graph, then compile it to create a ready-to-use DSP object as a C++ class, an LLVM or WebAssembly module, etc. to be used with all existing architecture files. </p>
<h4 id="who-is-this-tutorial-for">Who is this tutorial for?</h4>
<p>In this tutorial, we present the signal API with examples of code to show how to use it. The optimizations properties will be demonstrated looking at the generated C++ code. The goal is to demonstrate how more sophisticated languages (textual or graphical) could be built on top of the signal API.</p>
<h2 id="compiling-signal-expressions">Compiling signal expressions</h2>
<p>Using the signal API follows the scheme:</p>
<ul>
<li>creating a global compilation context using the <code>createLibContext</code> function. </li>
<li>creating signals outputs using the signal API, progressively building more complex expressions by combining simpler ones.</li>
<li>compiling the list of outputs using the <code>compileDSPSignalFactory</code> function to create a DSP factory. Then a DSP instance can be created and used with audio and UI architecture files. </li>
<li>finally destroying the compilation context using the <code>destroyLibContext</code> function. </li>
</ul>
<h3 id="examples">Examples</h3>
<p>For each example, the equivalent Faust DSP program and SVG diagram is given as helpers.</p>
<h4 id="tools">Tools</h4>
<p>Let's first define a compilation function, which uses the <code>compileDSPSignalFactory</code>function:</p>
<pre><code class="language-C++">static void compile(const string&amp; name, 
                    tvec signals, 
                    int argc = 0, 
                    const char* argv[] = nullptr)
{
    string error_msg;
    dsp_factory_base* factory = compileDSPSignalFactory(argc, 
                                                        argv, 
                                                        name, 
                                                        signals, 
                                                        error_msg);
    if (factory) {
        factory-&gt;write(&amp;cout);
        delete(factory);
    } else {
        cerr &lt;&lt; error_msg;
    }
}
</code></pre>
<p>And a macro to wrap all the needed steps: </p>
<pre><code class="language-C++">#define COMPILER(exp)    \
{                        \
    createLibContext();  \
    exp                  \
    destroyLibContext(); \
}                        \

</code></pre>
<h4 id="simple-constant-signal">Simple constant signal</h4>
<p>Let's create a program generating the 0.5 constant value. Here is the Faust DSP code:</p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust0/exfaust0.svg" class="mx-auto d-block">

<pre><code>
process = 0.5;

</code></pre>


<a href="https://faustide.grame.fr/?code=https://faustdoc.grame.fr/tutorials/signal-api/exfaust0/exfaust0.dsp" target="editor">
<button type="button" class="btn btn-primary">Try it Yourself >></button></a>
</div>
<!-- /faust-run -->

<p>The following code creates a vector of output signals (with the <code>tvec</code> type), containing the single <code>sigReal(0.5)</code> signal, then compile it and display the C++ class:</p>
<pre><code class="language-C++">
static void test1()
{
    COMPILER
    (
        tvec signals;
        signals.push_back(sigReal(0.5));

        compile(&quot;test1&quot;, signals);
    )
}
</code></pre>
<p>The <code>compute</code> method is then:</p>
<pre><code class="language-C++">virtual void compute(int count, FAUSTFLOAT** inputs, FAUSTFLOAT** outputs) 
{
    FAUSTFLOAT* output0 = outputs[0];
    for (int i0 = 0; (i0 &lt; count); i0 = (i0 + 1)) {
        output0[i0] = FAUSTFLOAT(0.5f);
    }
}
</code></pre>
<h4 id="doing-some-mathematical-operations-on-an-input-signal">Doing some mathematical operations on an input signal</h4>
<p>A program using a signal input and doing mathematical operations on it:</p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust1/exfaust1.svg" class="mx-auto d-block">

<pre><code>
process = _ &lt;: +(0.5), *(1.5);

</code></pre>


<a href="https://faustide.grame.fr/?code=https://faustdoc.grame.fr/tutorials/signal-api/exfaust1/exfaust1.dsp" target="editor">
<button type="button" class="btn btn-primary">Try it Yourself >></button></a>
</div>
<!-- /faust-run -->

<p>The first audio input is created with <code>sigInput(0)</code> signal, then transformed using <code>sigAdd</code> and <code>sigMul</code> signal operators to produce two outputs:</p>
<pre><code class="language-C++">static void test2()
{
    COMPILER
    (
        tvec signals;
        Signal in1 = sigInput(0);
        signals.push_back(sigAdd(in1, sigReal(0.5)));
        signals.push_back(sigMul(in1, sigReal(1.5)));

        compile(&quot;test2&quot;, signals);
     )
}
</code></pre>
<p>The <code>compute</code> method is then:</p>
<pre><code class="language-C++">virtual void compute(int count, FAUSTFLOAT** inputs, FAUSTFLOAT** outputs) 
{
    FAUSTFLOAT* input0 = inputs[0];
    FAUSTFLOAT* output0 = outputs[0];
    FAUSTFLOAT* output1 = outputs[1];
    for (int i0 = 0; (i0 &lt; count); i0 = (i0 + 1)) {
        float fTemp0 = float(input0[i0]);
        output0[i0] = FAUSTFLOAT((fTemp0 + 0.5f));
        output1[i0] = FAUSTFLOAT((1.5f * fTemp0));
    }
}
</code></pre>
<p>Note that accessing input N is simply done using the <code>sigInput(N)</code>expression. </p>
<h4 id="defining-delayed-signals">Defining delayed signals</h4>
<p>A program using a signal input and doing mathematical operations on it, then delaying the signals: </p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust2/exfaust2.svg" class="mx-auto d-block">

<pre><code>
process = _ &lt;: @(+(0.5), 500), @(*(1.5), 3000);

</code></pre>


<a href="https://faustide.grame.fr/?code=https://faustdoc.grame.fr/tutorials/signal-api/exfaust2/exfaust2.dsp" target="editor">
<button type="button" class="btn btn-primary">Try it Yourself >></button></a>
</div>
<!-- /faust-run -->

<p>The  <code>sigFixDelay(x, y)</code> operator is used to delay the <code>x</code> first parameter with the second <code>y</code> parameter, here with constant values:</p>
<pre><code class="language-C++">static void test3()
{
    COMPILER
    (
        tvec signals;
        Signal in1 = sigInput(0);
        signals.push_back(sigFixDelay(sigAdd(in1, sigReal(0.5)), sigReal(500)));
        signals.push_back(sigFixDelay(sigMul(in1, sigReal(1.5)), sigReal(3000)));

        compile(&quot;test3&quot;, signals);
    )
}
</code></pre>
<p>The <code>compute</code> method is then:</p>
<pre><code class="language-C++">virtual void compute(int count, FAUSTFLOAT** inputs, FAUSTFLOAT** outputs) 
{
    FAUSTFLOAT* input0 = inputs[0];
    FAUSTFLOAT* output0 = outputs[0];
    FAUSTFLOAT* output1 = outputs[1];
    for (int i0 = 0; (i0 &lt; count); i0 = (i0 + 1)) {
        float fTemp0 = float(input0[i0]);
        fVec0[(IOTA &amp; 4095)] = fTemp0;
        fVec1[(IOTA &amp; 511)] = (fTemp0 + 0.5f);
        output0[i0] = FAUSTFLOAT(fVec1[((IOTA - 500) &amp; 511)]);
        output1[i0] = FAUSTFLOAT((1.5f * fVec0[((IOTA - 3000) &amp; 4095)]));
        IOTA = (IOTA + 1);
    }
}
</code></pre>
<p>Several options of the Faust compiler allow to control the generated C++ code. By default computation is done sample by sample in a single loop. But the <a href="https://faustdoc.grame.fr/manual/compiler/#controlling-code-generation">compiler can also generate vector and parallel code</a>. The following code show how to compile in vector mode:</p>
<pre><code class="language-C++">static void test5()
{
    createLibContext();

    tvec signals;
    Signal in1 = sigInput(0);
    signals.push_back(sigFixDelay(sigAdd(in1, sigReal(0.5)), sigReal(500)));
    signals.push_back(sigFixDelay(sigMul(in1, sigReal(1.5)), sigReal(3000)));

    // Vector compilation
    compile(&quot;test5&quot;, signals, 3, (const char* []){ &quot;-vec&quot;, &quot;-lv&quot;, &quot;1&quot; });

    destroyLibContext();
}
</code></pre>
<p>The <code>compute</code> method is then:</p>
<pre><code class="language-C++">virtual void compute(int count, FAUSTFLOAT** inputs, FAUSTFLOAT** outputs) {
    FAUSTFLOAT* input0_ptr = inputs[0];
    FAUSTFLOAT* output0_ptr = outputs[0];
    FAUSTFLOAT* output1_ptr = outputs[1];
    for (int vindex = 0; (vindex &lt; count); vindex = (vindex + 32)) {
        FAUSTFLOAT* input0 = &amp;input0_ptr[vindex];
        FAUSTFLOAT* output0 = &amp;output0_ptr[vindex];
        FAUSTFLOAT* output1 = &amp;output1_ptr[vindex];
        int vsize = std::min&lt;int&gt;(32, (count - vindex));
        /* Vectorizable loop 0 */
        /* Pre code */
        fYec0_idx = ((fYec0_idx + fYec0_idx_save) &amp; 4095);
        /* Compute code */
        for (int i = 0; (i &lt; vsize); i = (i + 1)) {
            fYec0[((i + fYec0_idx) &amp; 4095)] = float(input0[i]);
        }
        /* Post code */
        fYec0_idx_save = vsize;
        /* Vectorizable loop 1 */
        /* Pre code */
        fYec1_idx = ((fYec1_idx + fYec1_idx_save) &amp; 1023);
        /* Compute code */
        for (int i = 0; (i &lt; vsize); i = (i + 1)) {
            fYec1[((i + fYec1_idx) &amp; 1023)] = (float(input0[i]) + 0.5f);
        }
        /* Post code */
        fYec1_idx_save = vsize;
        /* Vectorizable loop 2 */
        /* Compute code */
        for (int i = 0; (i &lt; vsize); i = (i + 1)) {
            output0[i] = FAUSTFLOAT(fYec1[(((i + fYec1_idx) - 500) &amp; 1023)]);
        }
        /* Vectorizable loop 3 */
        /* Compute code */
        for (int i = 0; (i &lt; vsize); i = (i + 1)) {
            output1[i] = FAUSTFLOAT((1.5f * fYec0[(((i + fYec0_idx) - 3000) &amp; 4095)]));
        }
    }
}
</code></pre>
<p>And can possibly be faster if the C++ compiler can auto-vectorize it.</p>
<p>If the delay operators are used on the input signal <em>before</em> the mathematical operations, then <em>a single delay</em> line will be created, taking the maximum size of both delay lines:</p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust3/exfaust3.svg" class="mx-auto d-block">

<pre><code>
process = _ &lt;: @(500) + 0.5, @(3000) * 1.5;

</code></pre>


<a href="https://faustide.grame.fr/?code=https://faustdoc.grame.fr/tutorials/signal-api/exfaust3/exfaust3.dsp" target="editor">
<button type="button" class="btn btn-primary">Try it Yourself >></button></a>
</div>
<!-- /faust-run -->

<p>And built with the following code:</p>
<pre><code class="language-C++">static void test4()
{
    COMPILER
    (
        tvec signals;
        Signal in1 = sigInput(0);
        signals.push_back(sigAdd(sigFixDelay(in1, sigReal(500)), sigReal(0.5)));
        signals.push_back(sigMul(sigFixDelay(in1, sigReal(3000)), sigReal(1.5)));

        compile(&quot;test4&quot;, signals);
    )
}
</code></pre>
<p>In the <code>compute</code> method, the single <code>fVec0</code> delay line is read at 2 differents indexes:</p>
<pre><code class="language-C++">virtual void compute(int count, FAUSTFLOAT** inputs, FAUSTFLOAT** outputs) 
{
    FAUSTFLOAT* input0 = inputs[0];
    FAUSTFLOAT* output0 = outputs[0];
    FAUSTFLOAT* output1 = outputs[1];
    for (int i0 = 0; (i0 &lt; count); i0 = (i0 + 1)) {
        float fTemp0 = float(input0[i0]);
        fVec0[(IOTA &amp; 4095)] = fTemp0;
        output0[i0] = FAUSTFLOAT((fVec0[((IOTA - 500) &amp; 4095)] + 0.5f));
        output1[i0] = FAUSTFLOAT((1.5f * fVec0[((IOTA - 3000) &amp; 4095)]));
        IOTA = (IOTA + 1);
    }
}
</code></pre>
<h4 id="equivalent-signal-expressions">Equivalent signal expressions</h4>
<p>It is really important to note that <em>syntactically equivalent signal expressions</em> will be <em>internally represented by the same memory structure</em> (using hashconsing), thus treated in the same way in the further compilations steps. So the following code where the <code>s1</code> variable is created to define the <code>sigAdd(sigFixDelay(sigInput(0), sigReal(500)), sigReal(0.5))</code> expression, then used in both outputs:</p>
<pre><code class="language-C++">static void equivalent1()
{
    COMPILER
    (
        tvec signals;
        Signal s1 = sigAdd(sigFixDelay(sigInput(0), sigReal(500)), sigReal(0.5))
        signals.push_back(s1);
        signals.push_back(s1);

        compile(&quot;equivalent1&quot;, signals);
    )
}
</code></pre>
<p>Will behave exactly the same as the following code, where the <code>sigAdd(sigFixDelay(sigInput(0), sigReal(500)), sigReal(0.5))</code> expression is used twice:</p>
<pre><code class="language-C++">static void equivalent2()
{
    COMPILER
    (
        tvec signals;
        signals.push_back(sigAdd(sigFixDelay(sigInput(0), sigReal(500)), sigReal(0.5)));
        signals.push_back(sigAdd(sigFixDelay(sigInput(0), sigReal(500)), sigReal(0.5)));

        compile(&quot;equivalent2&quot;, signals);
    )
}
</code></pre>
<p>It can be a property to remember when creating a DSL on top of the signal API.</p>
<h4 id="using-user-interface-items">Using User Interface items</h4>
<p>User Interface items can be used, as in the following example, with a <code>vslider</code>:</p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust4/exfaust4.svg" class="mx-auto d-block">

<pre><code>
process = @(+(0.5), 500) * vslider(&quot;Vol&quot;, 0.5, 0, 1, 0.01);

</code></pre>


<a href="https://faustide.grame.fr/?code=https://faustdoc.grame.fr/tutorials/signal-api/exfaust4/exfaust4.dsp" target="editor">
<button type="button" class="btn btn-primary">Try it Yourself >></button></a>
</div>
<!-- /faust-run -->

<p>Built with the following code:</p>
<pre><code class="language-C++">static void test8()
{
    COMPILER
    (
        tvec signals;
        Signal in1 = sigInput(0);
        Signal s = sigVSlider(&quot;Vol&quot;, sigReal(0.5), sigReal(0.), sigReal(1.), sigReal(0.01));
        signals.push_back(sigMul(s, sigFixDelay(sigAdd(in1, sigReal(0.5)), sigReal(500))));

        compile(&quot;test8&quot;, signals);
    )
}
</code></pre>
<p>The <code>buildUserInterface</code> method is generated, using the <code>fVslider0</code> variable:</p>
<pre><code class="language-C++">virtual void buildUserInterface(UI* ui_interface) 
{
    ui_interface-&gt;openVerticalBox(&quot;test8&quot;);
    ui_interface-&gt;addVerticalSlider(&quot;Vol&quot;, &amp;fVslider0, FAUSTFLOAT(0.5f),
                                  FAUSTFLOAT(0.0f), 
                                  FAUSTFLOAT(1.0f), 
                                  FAUSTFLOAT(0.00999999978f));
    ui_interface-&gt;closeBox();
}
</code></pre>
<p>The <code>compute</code> method is then: </p>
<pre><code class="language-C++">virtual void compute(int count, FAUSTFLOAT** inputs, FAUSTFLOAT** outputs) 
{
    FAUSTFLOAT* input0 = inputs[0];
    FAUSTFLOAT* output0 = outputs[0];
    float fSlow0 = float(fVslider0);
    for (int i0 = 0; (i0 &lt; count); i0 = (i0 + 1)) {
        fVec0[(IOTA &amp; 511)] = (float(input0[i0]) + 0.5f);
        output0[i0] = FAUSTFLOAT((fSlow0 * fVec0[((IOTA - 500) &amp; 511)]));
        IOTA = (IOTA + 1);
    }
}
</code></pre>
<p>User Interface layout can be described with <a href="https://faustdoc.grame.fr/manual/syntax/#hgroup-primitive">hgroup</a>, or <a href="https://faustdoc.grame.fr/manual/syntax/#vgroup-primitive">vgroup</a> or <a href="https://faustdoc.grame.fr/manual/syntax/#tgroup-primitive">tgroup</a>. With the signal API, the layout can be defined using the <a href="https://faustdoc.grame.fr/manual/syntax/#labels-as-pathnames">labels-as-pathnames</a> syntax, as in the following example:</p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust5/exfaust5.svg" class="mx-auto d-block">

<pre><code>
import(&quot;stdfaust.lib&quot;); 
freq = vslider(&quot;h:Oscillator/freq&quot;, 440, 50, 1000, 0.1); 
gain = vslider(&quot;h:Oscillator/gain&quot;, 0, 0, 1, 0.01); 
process = freq*gain;

</code></pre>


<a href="https://faustide.grame.fr/?code=https://faustdoc.grame.fr/tutorials/signal-api/exfaust5/exfaust5.dsp" target="editor">
<button type="button" class="btn btn-primary">Try it Yourself >></button></a>
</div>
<!-- /faust-run -->

<p>Built with the following code:</p>
<pre><code class="language-C++">static void test9()
{
    COMPILER
    (
        tvec signals;
        Signal freq = sigVSlider(&quot;h:Oscillator/freq&quot;, 
                                 sigReal(440), sigReal(50), 
                                 sigReal(1000), sigReal(0.1));
        Signal gain = sigVSlider(&quot;h:Oscillator/gain&quot;, 
                                 sigReal(0), sigReal(0), 
                                 sigReal(1), sigReal(0.011));
        signals.push_back(sigMul(freq, sigMul(gain, sigInput(0))));

        compile(&quot;test9&quot;, signals);
    )
}
</code></pre>
<p>The <code>buildUserInterface</code> method is generated (TODO):</p>
<h4 id="defining-recursive-signals">Defining recursive signals</h4>
<p>Recursive signals can be defined using the <code>sigRecursion</code> function and the <code>sigSelf</code> function to refer to the recursive signal itself. A one sample delay is automatically created to produce a valid computation. Here is a simple example:</p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust6/exfaust6.svg" class="mx-auto d-block">

<pre><code>
process = + ~ _;

</code></pre>


<a href="https://faustide.grame.fr/?code=https://faustdoc.grame.fr/tutorials/signal-api/exfaust6/exfaust6.dsp" target="editor">
<button type="button" class="btn btn-primary">Try it Yourself >></button></a>
</div>
<!-- /faust-run -->

<p>Built with the following code:</p>
<pre><code class="language-C++">static void test10()
{
    COMPILER
    (
        tvec signals;
        Signal in1 = sigInput(0);
        signals.push_back(sigRecursion(sigAdd(sigSelf(), in1)));

        compile(&quot;test10&quot;, signals);
    )
}
</code></pre>
<p>The <code>compute</code> method shows the <code>fRec0</code>variable that keeps the delayed signal:</p>
<pre><code class="language-C++">virtual void compute(int count, FAUSTFLOAT** inputs, FAUSTFLOAT** outputs) 
{
    FAUSTFLOAT* input0 = inputs[0];
    FAUSTFLOAT* output0 = outputs[0];
    for (int i0 = 0; (i0 &lt; count); i0 = (i0 + 1)) {
        fRec0[0] = (float(input0[i0]) + fRec0[1]);
        output0[i0] = FAUSTFLOAT(fRec0[0]);
        fRec0[1] = fRec0[0];
    }
}
</code></pre>
<h4 id="accessing-the-global-context">Accessing the global context</h4>
<p>In Faust, the underlying audio engine sample rate and buffer size  is accessed using the foreign function or constant mechanism. The values can also be used in the signal language with the following helper functions: </p>
<pre><code class="language-C++">// Reproduce the 'SR' definition in platform.lib 
// SR = min(192000.0, max(1.0, fconstant(int fSamplingFreq, &lt;dummy.h&gt;)));
inline Signal getSampleRate()
{
    return sigMin(sigReal(192000.0), 
           sigMax(sigReal(1.0), 
           sigFConst(SType::kSInt, &quot;fSamplingFreq&quot;, &quot;&lt;dummy.h&gt;&quot;)));
}

// Reproduce the 'BS' definition in platform.lib 
// BS = fvariable(int count, &lt;dummy.h&gt;);
inline Signal getBufferSize()
{
    return sigFVar(SType::kSInt, &quot;count&quot;, &quot;&lt;dummy.h&gt;&quot;);
}
</code></pre>
<p>So the following DSP program:</p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust7/exfaust7.svg" class="mx-auto d-block">

<pre><code>
import(&quot;stdfaust.lib&quot;); 
process = ma.SR, ma.BS;

</code></pre>


<a href="https://faustide.grame.fr/?code=https://faustdoc.grame.fr/tutorials/signal-api/exfaust7/exfaust7.dsp" target="editor">
<button type="button" class="btn btn-primary">Try it Yourself >></button></a>
</div>
<!-- /faust-run -->

<p>Can be written at the signal API level with:</p>
<pre><code class="language-C++">static void test11()
{
    COMPILER
    (
        tvec signals;
        signals.push_back(getSampleRate());
        signals.push_back(getBufferSize());

        compile(&quot;test11&quot;, signals);
    )
}
</code></pre>
<p>And the resulting C++ class contains:</p>
<pre><code class="language-C++">virtual void instanceConstants(int sample_rate) 
{
    fSampleRate = sample_rate;
    fConst0 = std::min&lt;float&gt;(192000.0f, std::max&lt;float&gt;(1.0f, float(fSampleRate)));
}
</code></pre>
<p>and:</p>
<pre><code class="language-C++">virtual void compute(int count, FAUSTFLOAT** inputs, FAUSTFLOAT** outputs) 
{
    FAUSTFLOAT* output0 = outputs[0];
    FAUSTFLOAT* output1 = outputs[1];
    int iSlow0 = count;
    for (int i0 = 0; (i0 &lt; count); i0 = (i0 + 1)) {
        output0[i0] = FAUSTFLOAT(fConst0);
        output1[i0] = FAUSTFLOAT(iSlow0);
    }
}
</code></pre>
<h4 id="using-tables-todo">Using tables (TODO)</h4>
<h4 id="using-waveforms-todo">Using waveforms (TODO)</h4>
<h4 id="using-soundfiles-todo">Using soundfiles (TODO)</h4>
<h4 id="defining-more-complex-expressions-a-phasor-then-an-oscillator">Defining more complex expressions: a phasor then an oscillator</h4>
<p>More complex signal expressions can be defined. So the following DSP program:</p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust8/exfaust8.svg" class="mx-auto d-block">

<pre><code>
import(&quot;stdfaust.lib&quot;);
process = phasor(440)
 with {
     decimalpart(x) = x-int(x);
     phasor(f) = f/ma.SR : (+ : decimalpart) ~ _;
 };

</code></pre>


<a href="https://faustide.grame.fr/?code=https://faustdoc.grame.fr/tutorials/signal-api/exfaust8/exfaust8.dsp" target="editor">
<button type="button" class="btn btn-primary">Try it Yourself >></button></a>
</div>
<!-- /faust-run -->

<p>Can be built with some auxiliary functions:</p>
<pre><code class="language-C++">static Signal decimalpart(Signal x)
{
    return sigSub(x, sigIntCast(x));
}

static Signal phasor(Signal f)
{
    return sigRecursion(decimalpart(sigAdd(sigSelf(), sigDiv(f, getSampleRate()))));
}

</code></pre>
<p>And the main function:</p>
<pre><code class="language-C++">static void test17()
{
    COMPILER
    (
        tvec signals;
        signals.push_back(phasor(sigReal(440.0)));

        compile(&quot;test17&quot;, signals);
    )
}
</code></pre>
<p>Which produces the following <code>compute</code>method:</p>
<pre><code class="language-C++">virtual void compute(int count, FAUSTFLOAT** inputs, FAUSTFLOAT** outputs) 
{
    FAUSTFLOAT* output0 = outputs[0];
    for (int i0 = 0; (i0 &lt; count); i0 = (i0 + 1)) {
        fRec0[0] = (fConst0 + (fRec0[1] - float(int((fConst0 + fRec0[1])))));
        output0[i0] = FAUSTFLOAT(fRec0[0]);
        fRec0[1] = fRec0[0];
    }
}
</code></pre>
<p>Now the following oscillator:</p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust9/exfaust9.svg" class="mx-auto d-block">

<pre><code>
 import(&quot;stdfaust.lib&quot;);
 process = osc(440), osc(440)
 with {
    decimalpart(x) = x-int(x);
    phasor(f) = f/ma.SR : (+ : decimalpart) ~ _;
    osc(f) = sin(2 * ma.PI * phasor(f));
 };

</code></pre>


<a href="https://faustide.grame.fr/?code=https://faustdoc.grame.fr/tutorials/signal-api/exfaust9/exfaust9.dsp" target="editor">
<button type="button" class="btn btn-primary">Try it Yourself >></button></a>
</div>
<!-- /faust-run -->

<p>Can be built with:</p>
<pre><code class="language-C++">static Signal osc(Signal f)
{
    return sigSin(sigMul(phasor(f), sigMul(sigReal(2.0), sigReal(3.141592653))));
}

static void test18()
{
    COMPILER
    (
        tvec signals;
        signals.push_back(osc(sigReal(440.0)));
        signals.push_back(osc(sigReal(440.0)));

        compile(&quot;test18&quot;, signals);
    )
}
</code></pre>
<p>Which produces the following <code>compute</code> method, where one can see that since the <em>same</em> oscillator signal is used on both outputs, it is actually computed once and copied twice:</p>
<pre><code class="language-C++">virtual void compute(int count, FAUSTFLOAT** inputs, FAUSTFLOAT** outputs) 
{
    FAUSTFLOAT* output0 = outputs[0];
    FAUSTFLOAT* output1 = outputs[1];
    for (int i0 = 0; (i0 &lt; count); i0 = (i0 + 1)) {
        fRec0[0] = (fConst0 + (fRec0[1] - float(int((fConst0 + fRec0[1])))));
        float fTemp0 = std::sin((6.28318548f * fRec0[0]));
        output0[i0] = FAUSTFLOAT(fTemp0);
        output1[i0] = FAUSTFLOAT(fTemp0);
        fRec0[1] = fRec0[0];
    }
}
</code></pre>
<h2 id="executing-the-generated-code">Executing the generated code</h2>
<p>Using the LLVM or Interpreter backends allows to generate and execute the DSP on the fly. </p>
<h4 id="connecting-the-audio-layer-todo">Connecting the audio layer (TODO)</h4>
<h4 id="connecting-the-controller-layer-todo">Connecting the controller layer (TODO)</h4>
<h2 id="creating-a-signal-language-based-on-this-api">Creating a signal language based on this API</h2>
<p>Generating a complex graph by directly using the signal API can quickly become really tricky and unpracticable. So a language <em>created on top</em> of the signal API is usually needed. This is exactly what the Block Diagram Algebra is all about, and the entire Faust language itself. </p>
<p>But some other approaches can possibly by tested. The <a href="https://www.elementary.audio">Elementary audio language</a> for instance is built over a similar <a href="https://docs.elementary.audio/guides/making_sound">signal language</a> and uses JavaScript as the upper layer language to help buinding complex signal graphs programatically. Other approaches using graphical based tools could certainly be tested. </p></div>
            </div>
        </div>

        <footer class="col-md-12">
            <hr>
                <p>Copyright &copy; 2020-2021 <a href="https://www.grame.fr">Grame-CNCM</a></p>
        </footer>
        <script>
            var base_url = "../..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../../js/base.js" defer></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML" defer></script>
        <script src="../../search/main.js" defer></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
                <p>
                    From here you can search these documents. Enter
                    your search terms below.
                </p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
